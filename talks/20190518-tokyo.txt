# Vary talk transcript

Hello, I'm Andrew, and I would like to invite you to spend the next 30 minutes of your life listening to me talk about Feature Policy.  I am a big fan of the Web.  I used to be a member of the W3C technical architecture group, and I now work for Fastly, which serves a lot of the content on the web.
I care a lot about the evolution of the web. Many things, like geolocation, WebVR, and upgrades to JavaScript, add new features and capabilities to the platform, and allow us to do more with the web.  Today, I want to talk about something that does the opposite.  Feature policy helps us not by making the web bigger, but by making it smaller.
Why would that make sense?
Well.  Some things, it turns out, are a bad idea.  Sometimes they seem like a good idea at the time and then later we realise that they are problematic.  AppCache is a good example of this, and it was later replaced by Service Workers, which turn out to be a far better solution for creating offline experiences.
In other cases, solutions are perfectly good, and do a good job, sometimes for a long time, and help us grow and evolve the platform, but they simply reach the end of their useful life.  Patterns like domain sharding are a good example of this.  They gave us a performance boost, but then we invented HTTP2 and now we don't need domain sharding anymore.
Bad ideas become a problem when we can't move past them.  Right now, I'm in the middle of buying an apartment in a very old building, and part of the apartment does not appear on the plans, so it's possible that it was not an authorised addition to the property and might need to be removed.  However, I can't remove it, because the person who owns the apartment above has built something on top of it, so it's kind of essential to prevent his apartment from collapsing.
Today, the web is almost 30 years old.  We've made a lot of mistakes.  Let's look at how we've moved on from them in the past.
I'd like to invite you (if you can!) to cast your mind back to the year 2000, and see if you can remember what the web was like. The most popular phone of the time was the Nokia 3310, an amazing piece of technology.  It had the kind of battery life that meant you would go on a two week holiday and not bother to take the charger.
But my question to you is: what was the most popular JavaScript method used on the Web in 2000?  I don't have any data on this.  There was no HTTP Archive in 2000, no WebPageTest, yet I can be pretty confident that I know which method was the most popular.  This one.  Window.open.  That's because I remember the web in 2000 and it looked like this.
But the web doesn't look like this anymore. We fixed the problem, by restricting the circumstances in which you can invoke window.open.  Initially this was developers building browser extensions to block popups, then browser vendors building popup blocking into the browser itself.
We can think of the incentives here in terms of a kind of triangle of different perspectives: developers, browser vendors, and major web platforms like facebook and twitter that act as starting points or gateways to the rest of the web.  And we also have standards bodies like W3C, IETF and WHATWG, and regulators like the EU and national governments.  Everyone has their own part to play in pushing and pulling the web in different directions as it evolves, but no one person or organisation is in charge.
I like to compare this to much more mature ecosystems, like global aviation.  Somehow, millions of flights take place relatively efficiently every year and yet planes don't routinely crash into one another.  A complex network of commercial agreements, bilateral treaties, regulations and international standards keep our planes safely and efficiently flying without any central control.
Let's step forwards to another crisis in the evolution of the web.
The year is now 2007.  The most popular phone is the 1st generation Apple iPhone, the first device with a really usable web browser, though it didn't have any mobile data capability so you had to be on wifi to use it.
The web is no longer a crazy mess of popup windows, but now we have another problem.  Almost every website is using Shockwave Flash to display ads, and as well as being a vector for security vulnerabilities, it is also consuming a ton of system resources, often more than the browser itself (You can tell this screenshot is an early version of Chrome because it is only using a quarter of a gigabyte of RAM!).
In this case, Apple reacted to the need for Flash by simply saying they would not support it.  This is the open letter Steve Jobs wrote on the Apple website explaining that decision.  This intervention effectively killed Flash on the web.  Perhaps not immediately, but over the following few years, a whole industry re-tooled and stopped using Flash, accelerating the development of new solutions like Canvas.
Most people would look back on these interventions, blocking popups and dropping flash, as positive things for the web platform, which helped us evolve further and faster.
Let's move on to the Web's next crisis.
It's 2015.  The phone of the moment is a Samsung Galaxy S7.  Not only has it got fast mobile data, but multiple independently installable and updatable web browsers, and a super fast CPU with an insane number of cores and a silly name.
So with all this power at our disposal, at the fingertips of our users, is the web now a great experience?
Not really. Around this time, we were seeing an enormous increase in the average size of a webpage.  According to data from Speedcurve, between 2011 and 2017, the size increased 250%, with the last couple of years of that increase driven almost entirely by the growth of video.
The intervention here came from major web platforms, that no longer wanted to link to excessively heavy and slow-loading websites.  Google came up with AMP, or 'Accelerated Mobile Pages'.  This is a limited sub-set of the web platform, with constraints designed to guarantee a fast experience.
Facebook and Apple had their own variants too, creating a whole category of alternative web-like publishing formats that publishers started calling 'distributed content'.  The reason for that name was that typically, these highly optimised pages are distributed by the platform, not by the publisher, leading to suggestions that these technologies are creating walled gardens, and transferring power on the web from publishers and independent developers to the already powerful platform owners.
I was one of the people leading those suggestions, and I wrote this open letter last year to try and raise awareness within Google of how AMP might be a problem for the web.  Around 700 people from around the world signed it, and subsequently, Google did change the governance model of the AMP project.  They do remain in full control of it, though, as of today, and elements of it, especially the AMP Carousel in search, are problematic for me in particular.  But unlike with popup windows or Flash, not enough time has passed yet for history to judge whether this intervention was a good one for the web.
So here we are now in 2019.
Samsung is making phones with 8 CPU cores and screens that fold in half.  And the web is great now.  Except it isn't, really.  ZDNet wrote this article at the beginning of last year talking about Mozilla's plans for 2018, to tackle practices like bad ads, autoplaying video and sites that ask for notification permissions on pageload.  But ZDnet ironically displayed this article on a page with bad ads, autoplaying video and which asked for notification permissions on pageload.
We still need the web to be better.
So let's consider what we've learned here about what makes a good intervention. We need something that allows good practices to be declared, recognised, enforced and rewarded, protects the openness and decentralisation of the web, and which doesn't break anything - because that site that you built on Geocities in 1999 still needs to work.  It also needs to be a collaborative process, ideally not owned or controlled by any single entity.
Feature Policy is potentially that intervention, which will move today's web forward.  Let's look at what it is and how it works.
Feature Policy is an HTTP header, and the 'allow' attribute of iframes.  It is developer-controlled, so you can set your own feature policy for your site, which expresses a set of standards that your page will conform to.  If it doesn't conform to those standards, the browser can take action to enforce them.  The nature of the framework for feature policy, and the definitions of the policies themselves, are all open and it's possible for you to get involved in them.
Here's an example HTTP request, probably from around 1997 era.  It has a few request headers, describing the nature of the requestor, and a few response headers, describing the nature of the response.  These days, we add a lot of other headers, especially on the response, so an HTTP exchange today probably looks more like this.
Things like Content-Security-Policy and Strict-Transport-Security are new uses of HTTP headers to improve security and performance.  Feature-Policy is another of this newer generation of HTTP metadata.
Let's break down what this header value means.  If you've used Content Security Policy, it will look quite familiar to you; there are tokens representing specific behaviours, and then a list of origins, or the special keywords 'none', self or star.
In this case, we're saying that the current document and all subframes cannot use document.write, and equally the current document and all subframes are not allowed to autoplay video on pageload.  The document itself is allowed to emit sound, but no third party iframes will be allowed to do that.  In contrast, the unsized-media behaviour is allowed only on one specific third party origin, but not on the document's own origin.  We'll look at the unsized media behaviour in more detail in a minute.
So, time for a live demo?
I built this website, featurepolicy.info, and you're welcome to load this up yourself on your own device right now.  You'll need the latest version of Chrome Canary with the experimental web platform features flag enabled to see some of the policies working, but others may work on your normal browser.
First, let's look at a permissions feature: the camera policy governs access to the camera API. Normally, when a webpage tries to use the camera, the browser will prompt the user for consent.  Then, it will attach a permanent consent to that origin, so if I come back to the same page and it tries to use the camera again, I'm not prompted, it just works.
Feature policy adds an extra level of self-imposed governance to the use of the API.  So, if I write a feature policy setting camera to none, then even though the origin already has consent from the user to use the camera, it won't work, and will trigger a permissions error.  And incidentally, if the browser doesn't yet have consent from the user when the page tries to use the camera, it won't ask, it will just deny permission silently.
These permission related APIs are mostly now associated with a feature policy - so similar policies exist for geolocation, USB, and so on.
For me, though, the more interesting policies are those that describe behaviours that we want to try and eliminate from the web platform, because they stop us moving the web forward.  So let's look at an example of one of those: font-display-late-swap.
As I refresh this demo, you'll notice that my lovely web font is taking a while to load.  This is a pretty common experience - especially with English language content because we tend to use more webfonts more often than Japanese content does.  You'll be on a slow connection, maybe on the train, and you'll be loading a webpage, and you know that the text has loaded, but it won't be readable, because the font hasn't loaded yet.  This is often called a flash of invisible text (FOIT) or flash of unstyled text (FOUT).
This is annoying.  It would be better if the developer made more of an effort to ensure that the font loaded earlier, and that it was available when the text needed to be rendered.  Font-display-late-swap describes this annoying practice of loading the font after the text, and then swapping the rendered text (or invisible text) for text in the correct font.  Disabling that policy means we are not allowed to do that anymore, so if I do that now, my text renders with no delay, in the fallback font.  That's because by disallowing this policy, I've opted in to not being allowed to load my font after my text.
Another fun one is layout animations.  For several years now, we have had the ability to do animations on the web efficiently using CSS transforms and CSS animations, on GPU-accelerated render layers.  However, it's still common for sites to do animations that cause the browser to recalculate the layout of the entire page on each frame.  What you're seeing now is one of these highly inefficient animations.  Because it's a simple one, and my laptop is fast, it's still smooth, but it's way more expensive on my CPU than it needs to be.  If we disallow the 'layout-animations' policy, then I'm no longer allowed to do animations that trigger layout recalculation, and the browser will only display the start and end state of the animation, with none of the intermediate frames.
Now, earlier I mentioned unsized-images, so let's have a look at that one.  Most of us, when we build websites today, we put explicit dimensions on our image tags, either with a width and height attribute, or using CSS.  So the browser knows how to lay out the image elements, before loading the image data.
But, ever since the early days of the web, browsers have always been able to determine the size of an image element from the image itself.  It's a really bad idea to do this because the page can judder and jump around as the images load and size themselves, so it's much better to declare the sizes ahead of time.  Disallowing the unsized-media feature policy enforces that.
So here we have an image that is 150 wide by 300 tall, and the browser is rendering it correctly at that size by autodetecting the dimensions from the image itself.  So let's disallow that ability, then the browser has no idea how big the image should be, so according to the feature policy spec, it will make it 300 wide by 150 high.  That size is actually hard-coded into the spec, believe it or not, so in this case the image will look very stretched.
OK, I think we get the idea, so let's go back to the slides.
Looking at these bad-practice policies (what some people are also calling 'hopeful deprecations'), I wondered what the web would be like if I disallowed all of them.  You can do this quite easily with a web debugging proxy or a browser plugin.  I used Charles proxy, which is nothing to do with me but I do think it's a great tool.  I injected this, the strictest possible feature policy, into all the HTML page responses that I was receiving in Chrome, and I browsed the web to see how broken it is.
Bottom line: it's very broken.
To make this fair, let's start by looking at Fastly's own website.  Like a lot of websites, Fastly loads a few of our <script> tags synchronously, without any async or defer attributes.  Disallowing the sync-script policy prevents that, so those scripts just don't load.  Several of the scripts on our site DO load asynchronously, so this is a bit of a mess because the async scripts are expecting the sync scripts to be there, and they're not, so that triggers a bunch of JavaScript errors.
The reason you're not seeing our brand font is because of the font-display-late-swap policy, and you'll also notice here that the logo is not displaying.  This is quite interesting actually. Like a lot of responsive sites, the logo on the Fastly site can actually render at different sizes depending on the width of the viewport, but we only have one image file, and that image file is a bit bigger than the frame most of the time.  Feature policy says that's not good enough.  The image size doesn't match the frame, it's oversized, so it doesn't display.
So that's our website. We also have some really lovely customers who agreed to let me trash their websites by loading them with my super strict feature policy, so let's start by looking at Le Monde.  This is one of the most respected newspapers in the world.  The story here is actually remarkably similar - synchronous script, images that aren't sized or optimised enough, but Le Monde also has animations that trigger layout recalculation, so those are being blocked by the layout-animations rule that I demoed earlier on.
Now, closer to home, let's look at Nikkei.  Here the problem is mainly unoptimised images, you can see particularly that these thumbnails are rather large in terms of data compared to their physical size.  Feature policy doesn't like that.  Nikkei also has a couple of synchronous scripts, similar to Le Monde.
I picked publishers to show you because these are highly advanced development teams of skilled engineers.   They go to conferences like this one - in fact, I think we have the Nikkei team here.  They know the best practices.  But large apps like news websites or ecommerce sites can't change their architecture quickly, so this is a good demonstration of how feature policy sets out a challenge for even the best of the web.
Some sites can change more quickly though.  What websites can we think of that are small, and built by the very best engineering minds, on the cutting edge of web innovation?  Perhaps… rebuild fm?  This is the rebuild fm page with my feature policy enforced.  Looks pretty good, huh?  Anyone see anything wrong?
Well done if you spotted it - the icons on the menu here are not displaying correctly. Unfortunately even Miyagawa has a feature policy violation, and it's font-display-late-swap again.  But that's the only problem with rebuild fm - so we can be sure that the site will function correctly, unlike sites that were relying on synchronous script.  Compared to non-functional buttons and menus, this is an almost perfect result.
Almost perfect. So. Who do I know in the Japanese web development community that is almost certainly on top of Feature Policy and probably tested their site already…?
Last year I did a lot of talks about HTTP headers, and I discovered that at the time I did my research, only about 20 domains in the world were sending an Accept-CH header for Client Hints.  This was one of them.
Jack, I think you are also in the room today, so you'd better hope this is a good result.  Well…
Of course it is.  No feature policies triggered.  Congratulations, Jack, the first website I've ever tested with a totally clean result.
Anyway, it's fun to dig into the web and see how other people build their sites, but how do we debug this.  Let's assume that Miyagawa wants to comply with all the feature policies, including font-display-late-swap, but the browser he's using to develop rebuild.fm does not support that policy yet.  He might not know that the policy is causing a bad effect for some users.
This is where the Reporting API can help.  The Reporting API is another web standard, not designed specifically for Feature Policy - it is actually used most commonly for Content Security Policy, but it can be used with Feature Policy too.  Using a few lines of JavaScript, we can set up a reporting observer, and get a callback to a custom function when something happens in the browser that we're interested in. Feature policy violations are one of the things that we can observe.
Even more useful, the reporting API can also be invoked via an HTTP header.  This is an example, and don't ask me why it's formatted using JSON… but anyway configuring the header like this allows the browser to send violation reports to your server as beacons.  Beacons are simple HTTP POST requests, independent of your page's JavaScript, so even if nothing works on your page at all, you can still get the reports.
I've talked about just a few policies today.  This is a list of all the policies that have been shipped in Chrome.  Red ones are the ones that are guarding so-called "powerful" features, whereas the blue ones are the "hopeful deprecations", the policies that guard bad practices that we might want to try and discourage to help the web to evolve.
Before I finish, hopefully you remember that earlier I mentioned ZDnet and showed that they prompt for permission to display notifications on page load.  I don't want to single-out ZDnet for this.  They are certainly not the only site to do it.  Here's Google doing the same thing in Google Calendar.  I find this behaviour really annoying.
So this is a great opportunity to propose a new policy.  I suggested we call it "unsolicited permission request" and define it as any user-consent prompt that is triggered without a user action.  You can do this too, and if you want help doing it in English, I'm very happy to help you, so please contact me here and I can also practice my Japanese.
We're also already seeing proposals that build on top of feature policy.  Alex Russell from Google has proposed that we create a kind of mega-policy he calls "Never slow mode".  You activate it with a policy called 'allow-slow' which will be defined as all of the bad practices, plus some strict resource limits per user interaction.  This would include some interesting constraints, like no more than 200ms of main thread execution per JavaScript task.
Do you think that's reasonable? What about the other limits here? If you want to influence these limits, now is the time to get involved and make your voice heard.
In conclusion, Feature Policy is coming, and it's going to make a difference to the way we build for the web.  You can do two things.  First, make sure you are already doing the things that are today's best practices: load all your scripts asynchronously, optimise all your media, don't autoplay videos, block font rendering or use layout thrashing animations.  But more importantly, take a look at the spec and get involved if you can.  This is the first time that developer best practice has become a part of the web platform, part of the standards that define the web itself.  Make sure you don't get taken by surprise, and embrace the opportunity to make the next great leap forward.
